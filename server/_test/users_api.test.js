const mongoose = require('mongoose');
// eslint-disable-next-line node/no-unpublished-require
const supertest = require('supertest');

const app = require('../app');
const { mongoConnection, bcryptUtils } = require('../utils');

const { expectResponseValues, usersHelper } = require('../testUtils');

const api = supertest(app);
const ENDPOINT_BASE = '/api/users';

describe('/api/users endpoints', () => {
  const initialItems = usersHelper.getInitialItems();

  beforeAll(async () => {
    await mongoConnection.connectToMongo();
    console.log('Test suite connected to Mongo');
  });

  beforeEach(async () => {
    await usersHelper.clearItemsInDB();

    const setupItems = usersHelper.getInitialItems();
    const promises = setupItems.map((item) => usersHelper.postItemToDB(item));

    await Promise.all(promises);
  });

  describe('GET calls users', () => {
    test('GET default environment with n initial users', async () => {
      // setup
      const response = await api.get(ENDPOINT_BASE);
      expect(response.body).toHaveLength(initialItems.length);
      // assert
      for (const [index, apiItem] of response.body.entries()) {
        expect(apiItem.username).toEqual(initialItems[index].username);
        expect(apiItem.name).toEqual(initialItems[index].name);
        // ** not returned from api
        expect(apiItem.password).not.toBeDefined();
        expect(apiItem.passwordHash).not.toBeDefined();
        // ** generated by api
        expect(Array.isArray(apiItem.blogs)).toBeTruthy();
        expect(apiItem.blogs).toHaveLength(0);
        expect(Array.isArray(apiItem.contacts)).toBeTruthy();
        expect(apiItem.contacts).toHaveLength(0);
      }
    });
    test('GET users are returned as json', async () => {
      await api
        .get(ENDPOINT_BASE)
        .expect(200)
        .expect('Content-Type', /application\/json/);
    });

    test('GET users have db-generated id', async () => {
      const response = await api.get(ENDPOINT_BASE).expect(200);

      for (const item of response.body) {
        expect(item.id).toBeDefined();
      }
    });

    test('GET users to not return password or passwordHash', async () => {
      const response = await api.get(ENDPOINT_BASE).expect(200);

      for (const item of response.body) {
        expect(item.password).not.toBeDefined();
        expect(item.passwordHash).not.toBeDefined();
      }
    });

    test('GET handles incorrect endpoint', async () => {
      await api
        .get(`${ENDPOINT_BASE}incorrect`)
        .expect(404)
        .expect('Content-Type', /application\/json/);
    });
  });

  describe('GET by id calls users', () => {
    test('GET by id works', async () => {
      // setup
      const allItems = await usersHelper.getItemsInDB();
      const firstItemId = allItems[0].id;
      const response = await api
        .get(`${ENDPOINT_BASE}/${firstItemId}`)
        .expect(200)
        .expect('Content-Type', /application\/json/);
      // assert
      expectResponseValues(
        { username: initialItems[0].username, name: initialItems[0].name },
        response.body
      );
      expect(response.body.id).toEqual(firstItemId);
    });

    test('GET from invalid id 400 Bad Request', async () => {
      // setup
      const bogusId = '000000000000000000000000';
      // act
      const putResponse = await api
        .get(`${ENDPOINT_BASE}/${bogusId}`)
        .expect(404);
      // assert
      expect(putResponse.body.error).toEqual('Item id does not exist.');
    });

    test('GET to impossible id 404 Not Found', async () => {
      // setup
      const bogusId = 'abc';
      // act
      const putResponse = await api
        .get(`${ENDPOINT_BASE}/${bogusId}`)
        .expect(400);
      // assert
      expect(putResponse.body.error).toEqual('Malformatted id.');
    });
  });

  describe('POST calls users', () => {
    test('POST works', async () => {
      // setup
      const originalDBItems = await usersHelper.getItemsInDB();
      const originalDBItemsLength = originalDBItems.length;

      const postItem = {
        username: 'newguy',
        name: 'New Guy',
        password: 'newguy4321',
      };
      // act
      const postResponse = await api
        .post(ENDPOINT_BASE)
        .send(postItem)
        .expect(201)
        .expect('Content-Type', /application\/json/);
      // assert

      expect(postResponse.body.username).toEqual(postItem.username);
      expect(postResponse.body.name).toEqual(postItem.name);
      expect(postResponse.body.id).toBeDefined();
      expect(postResponse.body.password).not.toBeDefined();
      expect(postResponse.body.passwordHash).not.toBeDefined();
      expect(postResponse.body.blogs).toHaveLength(0);
      expect(postResponse.body.contacts).toHaveLength(0);

      // reconfirm with GET by id
      const postedItemId = postResponse.body.id;
      // assert
      const getByIdResponse = await api.get(`${ENDPOINT_BASE}/${postedItemId}`);
      expect(getByIdResponse.body.username).toEqual(postItem.username);
      expect(getByIdResponse.body.name).toEqual(postItem.name);
      expect(getByIdResponse.body.id).toBeDefined();
      expect(getByIdResponse.body.password).not.toBeDefined();
      expect(getByIdResponse.body.passwordHash).not.toBeDefined();
      expect(getByIdResponse.body.blogs).toHaveLength(0);
      expect(getByIdResponse.body.contacts).toHaveLength(0);

      const updatedDBItems = await usersHelper.getItemsInDB();
      const updatedDBItemsLength = updatedDBItems.length;
      expect(updatedDBItemsLength).toEqual(originalDBItemsLength + 1);
    });

    test('POST defaults blogs and contacts to empty arrays', async () => {
      // setup
      const postItem = {
        username: 'another_guy',
        name: 'Another Guy',
        password: 'another_guy4321',
      };
      // act
      const postResponse = await api
        .post(ENDPOINT_BASE)
        .send(postItem)
        .expect(201)
        .expect('Content-Type', /application\/json/);
      // assert
      const updatedDBItems = await usersHelper.getItemsInDB();
      expect(
        updatedDBItems.find((item) => item.id === postResponse.body.id).blogs
      ).toHaveLength(0);
      expect(
        updatedDBItems.find((item) => item.id === postResponse.body.id).contacts
      ).toHaveLength(0);
    });

    test('POST rejects malformed data', async () => {
      // setup
      const invalidItem1 = {
        username: '',
        name: 'Good Name',
        password: 'good_password',
      };
      const invalidItem2 = {
        username: 'arealgoodusername',
        name: '',
        password: 'realgood_password',
      };
      const invalidItem3 = {
        username: 'superrealgoodusername',
        name: 'SuperGuy Mandude',
        password: undefined,
      };
      // act
      const postResponse1 = await api
        .post(ENDPOINT_BASE)
        .send(invalidItem1)
        .expect(400);
      const postResponse2 = await api
        .post(ENDPOINT_BASE)
        .send(invalidItem2)
        .expect(400);
      const postResponse3 = await api
        .post(ENDPOINT_BASE)
        .send(invalidItem3)
        .expect(400);
      // assert
      expect(postResponse1.body.error).toEqual(
        'User validation failed: username: Path `username` (``) is shorter than the minimum allowed length (3).'
      );
      expect(postResponse2.body.error).toEqual(
        'User validation failed: name: Path `name` (``) is shorter than the minimum allowed length (3).'
      );
      expect(postResponse3.body.error).toEqual('Missing passwordHash');
    });

    test.only('POST does not allow duplicate usernames', async () => {
      // setup
      const allItems = await usersHelper.getItemsInDB();
      const firstItem = allItems[0];

      const duplicateUsernameItem = {
        username: firstItem.username,
        name: 'Good Name',
        password: 'good_password',
      };
      // act

      const postResponse = await api
        .post(ENDPOINT_BASE)
        .send(duplicateUsernameItem)
        .expect(400);
      // assert
      expect(postResponse.body.error).toEqual('username must be unique.');
    });
  });

  describe('PUT calls users', () => {
    test('PUT works', async () => {
      // setup
      const allItems = await usersHelper.getItemsInDB();
      const firstItemId = allItems[0].id;
      const updatedItem = {
        username: 'updated_username',
        name: 'Updated Name',
        password: 'updated_password',
        blogs: ['000000000000000000000000'],
        contacts: ['000000000000000000000001'],
      };

      // act
      const putResponse = await api
        .put(`${ENDPOINT_BASE}/${firstItemId}`)
        .send(updatedItem)
        .expect(200)
        .expect('Content-Type', /application\/json/);
      // assert
      expect(putResponse.body.id).toEqual(firstItemId);
      expect(putResponse.body.username).toEqual(updatedItem.username);
      expect(putResponse.body.name).toEqual(updatedItem.name);
      expect(putResponse.body.password).not.toBeDefined();
      expect(putResponse.body.passwordHash).not.toBeDefined();
      expect(putResponse.body.blogs).toEqual(updatedItem.blogs);
      expect(putResponse.body.contacts).toEqual(updatedItem.contacts);
      // confirm assert
      const getDBItems = await usersHelper.getItemsInDB();
      const updatedDBItem = getDBItems.find((item) => item.id === firstItemId);
      expect(updatedDBItem.id).toEqual(firstItemId);
      expect(updatedDBItem.username).toEqual(updatedItem.username);
      expect(updatedDBItem.name).toEqual(updatedItem.name);
      expect(updatedDBItem.blogs).toHaveLength(updatedItem.blogs.length);
      expect(updatedDBItem.contacts).toHaveLength(updatedItem.contacts.length);
    });

    test('PUT to invalid id 400 Bad Request', async () => {
      // setup
      const bogusId = '000000000000000000000000';
      const updatedItem = {
        username: 'updated_username',
        name: 'Updated Name',
        password: 'updated_password',
      };
      // act
      const putResponse = await api
        .put(`${ENDPOINT_BASE}/${bogusId}`)
        .send(updatedItem)
        .expect(404);
      // assert
      expect(putResponse.body.error).toEqual('Item id does not exist.');
    });

    test('PUT to impossible id 404 Not Found', async () => {
      // setup
      const bogusId = 'abc';
      const updatedItem = {
        username: 'updated_username',
        name: 'Updated Name',
        password: 'updated_password',
      };
      // act
      const putResponse = await api
        .put(`${ENDPOINT_BASE}/${bogusId}`)
        .send(updatedItem)
        .expect(400);
      // assert
      expect(putResponse.body.error).toEqual('Malformatted id.');
    });

    test('PUT rejects malformed data', async () => {
      // setup
      const allItemsResponse = await api.get(ENDPOINT_BASE);
      const firstItemId = allItemsResponse.body[0].id;
      const invalidItem1 = {
        username: '',
      };
      const invalidItem2 = {
        name: '',
      };
      // act
      const putResponse1 = await api
        .put(`${ENDPOINT_BASE}/${firstItemId}`)
        .send(invalidItem1)
        .expect(400);
      const putResponse2 = await api
        .put(`${ENDPOINT_BASE}/${firstItemId}`)
        .send(invalidItem2)
        .expect(400);

      // assert
      expect(putResponse1.body.error).toEqual(
        'Validation failed: username: Path `username` (``) is shorter than the minimum allowed length (3).'
      );
      expect(putResponse2.body.error).toEqual(
        'Validation failed: name: Path `name` (``) is shorter than the minimum allowed length (3).'
      );
    });
  });
  describe('DELETE calls users', () => {
    test('DELETE works', async () => {
      // setup
      const allItems = await usersHelper.getItemsInDB();

      for (const item of allItems) {
        await api.delete(`${ENDPOINT_BASE}/${item.id}`).expect(204);
        // confirm with GET
        const confirmAllItemsResponse = await api.get(ENDPOINT_BASE);
        expect(
          confirmAllItemsResponse.body.some((c) => c.id === item.id)
        ).toEqual(false);
        // double-confirm with GET by ID
        await api.get(`${ENDPOINT_BASE}/${item.id}`).expect(404);
      }
      // Reconfirm GET all
      const reconfirmAllResponse = await api.get(ENDPOINT_BASE).expect(200);
      expect(reconfirmAllResponse.body).toHaveLength(0);
    });

    test('DELETE to invalid id 404 id does not exist', async () => {
      // setup
      const bogusId = '000000000000000000000000';
      // act
      const response = await api
        .delete(`${ENDPOINT_BASE}/${bogusId}`)
        .expect(404);
      // assert
      expect(response.body.error).toEqual('Item id does not exist.');
    });

    test('DELETE to impossible id 400 Not Found', async () => {
      // setup
      const bogusId = 'abc';
      // act
      const response = await api
        .delete(`${ENDPOINT_BASE}/${bogusId}`)
        .expect(400);
      // assert
      expect(response.body.error).toEqual('Malformatted id.');
    });
  });

  afterAll(async () => {
    const testDBName = process.env.MONGODB_CROSS_APP_DB_TEST;
    await mongoose.connection.useDb(testDBName).dropCollection('users');
    console.log('Dropped db', testDBName);
    await mongoose.connection.close();
    console.log('Disconnected from test db');
  });
});
